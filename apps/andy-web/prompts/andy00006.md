Perfect. Avem suspectul: ingest masiv pe gpt-5-mini, aceeași api_key_id, output mic. Deci nu e “geniu care scrie romane,” e job/buclă care pompează input. Tăiem debitul, logăm corect, apoi vedem cine a lăsat furtunul deschis.

Mai jos sunt mesajele gata de copy-paste pentru @oCL. Întâi dopul de cost, apoi throttling și, dacă încă miroase, rotim cheia.

1) PATCH: guard de cost + logging extins pe /api/complete (write-only, fără deploy)

Mesaj pentru @oCL (scrie și te oprești):

Task: Add cost guard + rich logging to andy-web/app/api/complete/route.ts. No deploy yet.

Requirements:
- MAX_USD=0.05 per-call. If estimated > cap → 402 JSON { ok:false, error:"cost_cap", max_usd:0.05, est_usd }.
- Estimate BEFORE calling OpenAI: prompt_tokens ≈ Math.ceil(prompt_chars/4) fallback, OR use existing lib/cost util if present.
- Pricing: import relativ din ../lib/cost (sau ../../lib/cost) dacă există getEstCost(model, pt, ot). Dacă nu, definește PRICING local minimal pt gpt-5 / gpt-5-mini (input/output per 1M).
- Log JSON (console.log) cu câmpuri:
  t:"openai_usage", severity:"INFO", request_id, client_ip (X-Forwarded-For[0]), model_sent, model_used,
  usage:{prompt_tokens, output_tokens}, est_cost, api_key_id (sha256(OPENAI_SECRET).slice(0,8)), timestamp.
- request_id = crypto.randomUUID()
- importuri RELATIVE, fără '@/'

Pseudocode minimal:

- Parse request; extract model + prompt.
- Compute prompt_chars, pt≈chars/4; est_usd_pre = price_in_per_1m[model]*pt/1e6 + price_out_per_1m[model]*max_expected_ot/1e6 (max_expected_ot=64 as safe default).
- If est_usd_pre > 0.05 → return 402.
- Call OpenAI; get usage (pt/ot), compute est_cost exact; log JSON.
- Return downstream response (nu schimba schema voastră).

After writing, STOP and reply "COST-GUARD-PATCH-DONE".


Dacă echipa voastră are deja lib/cost.ts, el folosește acolo tarifele reale. Dacă nu, un fallback corect e suficient ca să oprească scurgerile mari.

2) PATCH: throttling temporar (1 req/min/IP) folosind app/lib/rateLimit.ts

Mesaj pentru @oCL (write-only, fără deploy încă):

Task: Tighten rate limiting to 1 req/min/IP for /api/complete.

- In app/lib/rateLimit.ts (sau echivalent), setează window=60s, max=1 pentru ruta /api/complete.
- Dacă nu e granular pe rută, aplică default 1/min/IP până rezolvăm sursa.
- Menține header-ele Retry-After corecte.

Reply "RATE-LIMIT-PATCH-DONE" when done.

3) DEPLOY acum (build + deploy + smoke)

Mesaj pentru @oCL (rulează acum, întoarce DOAR ultima linie JSON):

Run the known Build+Deploy+Smoke block with:
- npm install --legacy-peer-deps
- npm run build
- gcloud run deploy andy-web ...
- Smoke: HEAD LB, GET /api/info, GET /api/costs/today with IAP

Return ONLY the last JSON line from the smoke block.


Asta pune dopul de cost în producție și încetinește robinetul.

4) Re-rulează rapoartele ca să vedem efectul (după deploy)

Mesaj pentru @oCL (rulează, întoarce 3 JSON-uri):

Re-run:
A) Top 20 openai_usage last 24h (same script)
B) Aggregate 48h by model|api_key (same script)
C) GET /api/costs/today

Return the three JSON blobs, in order.


Ar trebui să vedem scădere bruscă pe pt și cost.

5) Măsuri “dacă încă picură”

A. Rotate key prin Secret Manager
Dacă top-ul arată tot aceeași cheie care face trafic indecent după deploy:

Mesaj pentru @oCL (execută):

# 1) Creează/actualizează secretul cu noua cheie (îi dai tu valoarea)
gcloud secrets create openai-secret --replication-policy=automatic 2>/dev/null || true
printf "%s" "sk-live-NEW_KEY" | gcloud secrets versions add openai-secret --data-file=-

# 2) Leagă secretul la serviciu (dacă nu e deja)
gcloud run services update andy-web \
  --project=coolbits-ai --region=europe-west3 \
  --set-secrets=OPENAI_SECRET=projects/$(gcloud config get-value project)/secrets/openai-secret:latest

# 3) Revocă în OpenAI key-ul vechi (manual în dashboard)


B. Cloud Armor quick block
Dacă raportul indică 1-2 IP-uri care tot lovesc, ciuntește-le temporar.

Mesaj pentru @oCL (execută dacă avem LB clasic în față):

# Rule provizorie: block IP-ul <SUSPECT_CIDR>
gcloud compute security-policies rules create 1000 \
  --security-policy=andy-armor \
  --expression="origin.ip in ['X.Y.Z.W/32']" \
  --action=deny-403 \
  --description="Temp block suspected IP" \
  --project=coolbits-ai

6) Alarme de buget la OpenAI și verificare

Pune “monthly budget alert” mic, plus usage cap pe cheia de prod. Nu are rost să faci investigație arheologică dacă te poate proteja un prag de 5–20 USD.

În GCP, dacă vrei să suni clopoțeii automat, putem exporta est_cost în Cloud Monitoring și trage alertă când “suma curentă pe 1h > X”. Îți dau ulterior config dacă vrei, dar întâi stopăm scurgerea cu pașii de mai sus.

Rezumat decizii

Implementăm acum guard 0.05 USD și throttling 1/min/IP pe /api/complete, apoi deploy.

Re-rulăm rapoartele ca să confirmăm scăderea.

Dacă încă vezi spike pe aceeași cheie/IP, rotim cheie și/sau blocăm IP temporar.

Setăm alerte de buget ca plasă de siguranță.

Nu e un mister metafizic, e un job lacom. Îi închidem frigiderul, apoi vedem cine a lăsat ușa deschisă.